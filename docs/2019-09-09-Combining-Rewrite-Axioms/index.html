<!DOCTYPE html>
<html lang="en">
  <head>
<meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, maximum-scale=1.0"
/>
<meta
  name="description"
  content="The symbolic execution engine powering the K Framework"
/>
<meta name="keywords" content="runtime, verification, rv, k, kore" />
<meta
  name="author"
  content="Kore | Runtime Verification Inc"
/>
<meta name="robots" content="index, follow" />

<!--favicon icon-->
<!-- <link rel="icon" type="image/png" href="../../assets/img/favicon.ico" /> -->

<title>Kore | Runtime Verification Inc</title>

<!-- <base href="/k/" /> -->

<!--web fonts-->
<link
  href="https://fonts.googleapis.com/css?family=Nunito:300,400,600,700,800"
  rel="stylesheet"
/>
<link
  href="https://fonts.googleapis.com/css?family=Lora:400i"
  rel="stylesheet"
/>

<link
  href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css"
  rel="stylesheet"
/>

<link href="../../assets/css/index.css" rel="stylesheet" />

<!--[if (gt IE 9) |!(IE)]><!-->
<!--<link rel="stylesheet" href="/assets/vendor/custom-nav/css/effects/fade-menu.css"/>-->
<!-- <link rel="stylesheet" href="../../assets/k/vl-nav/css/effects/slide-menu.css" /> -->
<!--<![endif]-->

  </head>

  <body>
<header
  class="navbar navbar-expand navbar-dark flex-column flex-md-row bd-navbar"
>
  <a class="logo-link" href="../../index.html">
    Kore
  </a>
  <ul class="navbar-nav ml-md-auto">
    <li class="nav-item">
      <a
        class="nav-link pl-2 pr-1 mx-1 py-3 my-n2"
        href="https://github.com/runtimeverification/algorand-sc-semantics"
        target="_blank"
        rel="noopener"
        aria-label="GitHub"
      >
        <i class="fab fa-github"></i>
      </a>
    </li>
  </ul>
  <!--
  <a
    class="btn btn-rv-blue d-none d-lg-inline-block mb-3 mb-md-0 ml-md-3"
    href="../../downloads"
    >Download</a
  >
  -->
</header>


    <div class="container-fluid">
      <div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 bd-sidebar mb-3">
  <form
    role="search"
    class="bd-search d-flex align-items-center justify-content-between"
  >
    <input
      type="search"
      class="form-control"
      placeholder="Search..."
      aria-label="Search for..."
      autocomplete="false"
      id="search-box"
    />
    <button
      class="btn bd-search-docs-toggle d-md-none p-0 ml-3 collapsed"
      type="button"
      aria-label="Toggle docs navigation"
      style="font-size: 1.4rem"
    >
      <i class="fas fa-bars"></i>
    </button>
  </form>
  <nav class="collapse bd-links" aria-label="Main navigation">
    <div class="bd-toc-item">
      <a class="bd-toc-link" href="../../">Homepage</a>
      <a class="bd-toc-link" href="../../docs/manual/DEVELOPER_MANUAL">Developer Manual</a>
    </div>
  </nav>
</div>

        <main
          class="col-12 col-md-6 col-xl-8 py-md-3 pl-md-5 bd-content"
          role="main"
        >
          <div class="markdown-preview"><html><head></head><body><h1 id="combining-rewrite-axioms">Combining rewrite Axioms</h1>
<p>In the
<a href="https://github.com/runtimeverification/polkadot-verification/issues/20" target="_blank" rel="noopener">Polkadot Verification</a>
issue, @ehildenb proposed that we should either apply a chain of rules to a
symbolic configuration consisting of a single variable, or we should be able to
combine rules into a single one. This document details the matching logic
reasoning and assumptions behind these.</p>
<h2 id="summary">Summary</h2>
<p>If we have this chain of axioms: <code>&#x3B1;&#x2081;(X&#x2081;)&#x21D2;&#x3B2;&#x2081;(X&#x2081;)</code> &#x2026; <code>&#x3B1;&#x2099;(X&#x2099;)&#x21D2;&#x3B2;&#x2099;(X&#x2099;)</code> in which
all the LHS are <em>function-like</em> and <em>injection-based</em>, and all the RHS
except <code>&#x3B2;&#x2099;(X&#x2099;)</code> are <em>function-like</em>, then their combined transition is</p>
<pre class="language-text"><code>(&#x2308;&#x3B2;&#x2081;(X&#x2081;)&#x2227;&#x3B1;&#x2082;(X&#x2082;)&#x2309; &#x2227; &#x2308;&#x3B2;&#x2082;(X&#x2082;)&#x2227;&#x3B1;&#x2083;(X&#x2083;)&#x2309; &#x2227; &#x2026; &#x2227; &#x2308;&#x3B2;&#x2099;&#x208B;&#x2081;(X&#x2099;&#x208B;&#x2081;)&#x2227;&#x3B1;&#x2099;(X&#x2099;)&#x2309; &#x2227; &#x3B1;&#x2081;(X&#x2081;))&#x2192;&#x2022;&#x2022;&#x2026;&#x2022;&#x3B2;&#x2099;(X&#x2099;)
</code></pre>
<p>TODO: We may need to figure out how to handle maps, sets, and other structures
based on non-injective symbols.</p>
<h2 id="the-general-transformation">The general transformation</h2>
<p>Let us take a configuration <code>&#x3C6;(X)</code> which is functional,
and which can be a single variable.</p>
<p>Let us also take a configuration <code>&#x3B1;(X)&#x2192;&#x2022;&#x3B2;(X)</code>, with <code>&#x3B1;(X)</code> being functional.
Then, similar to
<a href="../2018-11-08-Applying-Axioms/">basic symbolic execution algorithm</a>, we have:</p>
<pre class="language-text"><code>1. &#x3B1;(Y) &#x2192; &#x2022;&#x3B2;(Y) // the axiom
1. &#x3B1;(Y) &#x2227; &#x2308;&#x3B1;(Y) &#x2227; &#x3C6;(X)&#x2309; &#x2192; (&#x2022;&#x3B2;(Y)) &#x2227; &#x2308;&#x3B1;(Y) &#x2227; &#x3C6;(X)&#x2309;
   // from (1) and propositional reasoning
1. &#x3B1;(Y) &#x2227; &#x2308;&#x3B1;(Y) &#x2227; &#x3C6;(X)&#x2309; = &#x3B1;(Y) &#x2227; &#x3C6;(X)
   // ML paper Prop. 5.24, needs `&#x3B1;` and `&#x3C6;` to be functional
1. &#x3B1;(Y) &#x2227; &#x3C6;(X) &#x2192; (&#x2022;&#x3B2;(Y)) &#x2227; &#x2308;&#x3B1;(Y) &#x2227; &#x3C6;(X)&#x2309;
   // from (2) and (3)
1. &#x3C6;(X) &#x2227; &#x2308;&#x3B1;(Y) &#x2227; &#x3C6;(X)&#x2309; &#x2192; (&#x2022;&#x3B2;(Y)) &#x2227; &#x2308;&#x3B1;(Y) &#x2227; &#x3C6;(X)&#x2309;
   // from (3) and (4)
1. &#x3C6;(X) &#x2227; &#x2308;&#x3B1;(Y) &#x2227; &#x3C6;(X)&#x2309; &#x2192; &#x2203; Y . ((&#x2022;&#x3B2;(Y)) &#x2227; &#x2308;&#x3B1;(Y) &#x2227; &#x3C6;(X)&#x2309;)
   // FOL reasoning
1. &#x2200; Y . (&#x3C6;(X) &#x2227; &#x2308;&#x3B1;(Y) &#x2227; &#x3C6;(X)&#x2309; &#x2192; &#x2203; Y . ((&#x2022;&#x3B2;(Y)) &#x2227; &#x2308;&#x3B1;(Y) &#x2227; &#x3C6;(X)&#x2309;))
   // All unquantified variables are universal
1. &#x2200; Y . (&#x3C6;(X) &#x2227; &#x2308;&#x3B1;(Y) &#x2227; &#x3C6;(X)&#x2309; &#x2192; &#x2203; Y&#x2019; . ((&#x2022;&#x3B2;(Y&#x2019;)) &#x2227; &#x2308;&#x3B1;(Y&#x2019;) &#x2227; &#x3C6;(X)&#x2309;))
   // Renaming variables to make things clear
1. &#x2200; Y .
        ( &#x3C6;(X) &#x2227; &#x2308;&#x3B1;(Y) &#x2227; &#x3C6;(X)&#x2309;
        &#x2192; &#x2203; Y&#x2019; . ((&#x2022;&#x3B2;(Y&#x2019;)) &#x2227; &#x2308;&#x3B1;(Y&#x2019;) &#x2227; &#x3C6;(X)&#x2309; &#x2227; &#x2308;&#x3B1;(Y) &#x2227; &#x3C6;(X)&#x2309;)
        )
   // a &#x2227; b &#x2192; c is the same as a &#x2227; b &#x2192; c &#x2227; b
</code></pre>
<p>When doing normal rewriting, we usually expect to get substitutions for the
variables in <code>Y</code> and <code>Y&#x2019;</code> when computing <code>&#x2308;&#x3B1;(Y) &#x2227; &#x3C6;(X)&#x2309;</code>, which usually allows
us to remove these variables. However, when combining rewriting axioms,
we don&#x2019;t always get such substitutions, so we need to take a different approach.</p>
<p>First, let us note that if <code>&#x3C6;&#x2081;</code>, <code>&#x3C6;&#x2082;</code> and <code>&#x3C6;&#x2083;</code> are <em>functional</em>, then</p>
<pre class="language-text"><code>&#x2308;&#x3C6;&#x2081;&#x2227;&#x3C6;&#x2082;&#x2309; &#x2227; &#x2308;&#x3C6;&#x2081;&#x2227;&#x3C6;&#x2083;&#x2309;
= (&#x3C6;&#x2081; == &#x3C6;&#x2082;) &#x2227; (&#x3C6;&#x2081; == &#x3C6;&#x2083;)
= (&#x3C6;&#x2081; == &#x3C6;&#x2082;) &#x2227; (&#x3C6;&#x2082; == &#x3C6;&#x2083;)
= &#x2308;&#x3C6;&#x2081;&#x2227;&#x3C6;&#x2082;&#x2309; &#x2227; &#x2308;&#x3C6;&#x2082;&#x2227;&#x3C6;&#x2083;&#x2309;
</code></pre>
<p>So we have</p>
<pre class="language-text"><code>&#x2200; Y .
   ( &#x3C6;(X) &#x2227; &#x2308;&#x3B1;(Y) &#x2227; &#x3C6;(X)&#x2309;
   &#x2192; &#x2203; Y&#x2019; . ((&#x2022;&#x3B2;(Y&#x2019;)) &#x2227; &#x2308;&#x3B1;(Y&#x2019;) &#x2227; &#x3C6;(X)&#x2309; &#x2227; &#x2308;&#x3B1;(Y) &#x2227; &#x3C6;(X)&#x2309;)
   )
iff
&#x2200; Y .
   ( &#x3C6;(X) &#x2227; &#x2308;&#x3B1;(Y) &#x2227; &#x3C6;(X)&#x2309;
   &#x2192; &#x2203; Y&#x2019; . ((&#x2022;&#x3B2;(Y&#x2019;)) &#x2227; &#x2308;&#x3B1;(Y&#x2019;) &#x2227; &#x3C6;(X)&#x2309; &#x2227; &#x2308;&#x3B1;(Y&#x2019;) &#x2227; &#x3B1;(Y)&#x2309;)
   )
</code></pre>
<p>Now, if, additionally, <code>&#x3B1;(Y)</code> is <em>constructor-based</em> (or, at least,
injection-based), then</p>
<pre class="language-text"><code>&#x2308;&#x3B1;(Y&#x2019;) &#x2227; &#x3B1;(Y)&#x2309; iff Y = Y&#x2019;
</code></pre>
<p>Note that this might also hold in some constrained cases when using
non-constructor LHS, e.g. LHS that use maps or sets.
These are not detailed here.</p>
<p>So, assuming that, we have the following transformations:</p>
<pre class="language-text"><code>1. &#x2200; Y .
      ( &#x3C6;(X) &#x2227; &#x2308;&#x3B1;(Y) &#x2227; &#x3C6;(X)&#x2309;
      &#x2192; &#x2203; Y&#x2019; . ((&#x2022;&#x3B2;(Y&#x2019;)) &#x2227; &#x2308;&#x3B1;(Y&#x2019;) &#x2227; &#x3C6;(X)&#x2309; &#x2227; &#x2308;&#x3B1;(Y&#x2019;) &#x2227; &#x3B1;(Y)&#x2309;)
      )
1. &#x2200; Y . (&#x3C6;(X) &#x2227; &#x2308;&#x3B1;(Y) &#x2227; &#x3C6;(X)&#x2309; &#x2192; &#x2203; Y&#x2019; . ((&#x2022;&#x3B2;(Y&#x2019;)) &#x2227; &#x2308;&#x3B1;(Y&#x2019;) &#x2227; &#x3C6;(X)&#x2309; &#x2227; Y&#x2019;=Y))
   // Apply the formula above
1. &#x2200; Y . (&#x3C6;(X) &#x2227; &#x2308;&#x3B1;(Y) &#x2227; &#x3C6;(X)&#x2309; &#x2192; &#x2203; Y&#x2019; . ((&#x2022;&#x3B2;(Y)) &#x2227; &#x2308;&#x3B1;(Y) &#x2227; &#x3C6;(X)&#x2309; &#x2227; (Y&#x2019;=Y)))
   // Apply the substitution
1. &#x2200; Y . (&#x3C6;(X) &#x2227; &#x2308;&#x3B1;(Y) &#x2227; &#x3C6;(X)&#x2309; &#x2192; ((&#x2022;&#x3B2;(Y)) &#x2227; &#x2308;&#x3B1;(Y) &#x2227; &#x3C6;(X)&#x2309; &#x2227; (&#x2203; Y&#x2019; . Y&#x2019;=Y)))
   // &#x2203; Y . &#x3B6; &#x2227; &#x3C6;(Y) = &#x3B6; &#x2227; &#x2203; Y . &#x3C6;(Y)
1. &#x2200; Y . (&#x3C6;(X) &#x2227; &#x2308;&#x3B1;(Y) &#x2227; &#x3C6;(X)&#x2309; &#x2192; ((&#x2022;&#x3B2;(Y)) &#x2227; &#x2308;&#x3B1;(Y) &#x2227; &#x3C6;(X)&#x2309;))
   // (&#x2203; Y . Y == &#x3B6;) = &#x22A4;
1. &#x3C6;(X) &#x2227; &#x2308;&#x3B1;(Y) &#x2227; &#x3C6;(X)&#x2309; &#x2192; ((&#x2022;&#x3B2;(Y)) &#x2227; &#x2308;&#x3B1;(Y) &#x2227; &#x3C6;(X)&#x2309;)
   // &#x2200; is not needed at the top level
1. &#x3C6;(X) &#x2227; &#x2308;&#x3B1;(Y) &#x2227; &#x3C6;(X)&#x2309; &#x2192; &#x2022;&#x3B2;(Y)
   // (a &#x2227; c) &#x2192; (b &#x2227; c) iff (a &#x2227; c) &#x2192; b
</code></pre>
<h2 id="implementation-concerns">Implementation concerns</h2>
<h3 id="eliminating-variables">Eliminating variables</h3>
<p>Note that if <code>&#x2308;&#x3B1;(Y) &#x2227; &#x3C6;(X)&#x2309;</code> contains a substitution <code>y=&#x3B6;</code> then we can apply it
and remove the variable <code>y</code> from the expression above (proof not shown here, one
needs to transform</p>
<pre class="language-text"><code>&#x2200; Y . (&#x3C6;(X) &#x2227; &#x2308;&#x3B1;(Y) &#x2227; &#x3C6;(X)&#x2309; &#x2192; &#x2203; Y&#x2019; . (&#x2022;&#x3B2;(Y&#x2019;) &#x2227; &#x2308;&#x3B1;(Y&#x2019;) &#x2227; &#x3C6;(X)&#x2309;))).
</code></pre>
<p>into</p>
<pre class="language-text"><code>(&#x2203; Y . (&#x3C6;(X) &#x2227; &#x2308;&#x3B1;(Y) &#x2227; &#x3C6;(X)&#x2309;)) &#x2192; &#x2203; Y&#x2019; . (&#x2022;&#x3B2;(Y&#x2019;) &#x2227; &#x2308;&#x3B1;(Y&#x2019;) &#x2227; &#x3C6;(X)&#x2309;)
   // &#x2200; x . (&#x3C6;(x) -&gt; &#x3B6;)  ==  (&#x2203; x . &#x3C6;(x)) -&gt; &#x3B6;
</code></pre>
<p>above to make it work).</p>
<h3 id="using-function-like-patterns">Using function-like patterns</h3>
<p>Usually <code>&#x3C6;(X)</code> and <code>&#x3B1;(X)</code> are only function-like, but the above requires
functional patterns. We will show that the same formula also works for function-like patterns.</p>
<pre class="language-text"><code>1. &#x3C6;(X) &#x2227; &#x2308;&#x3B1;(Y) &#x2227; &#x3C6;(X)&#x2309; &#x2192; &#x2022;&#x3B2;(Y)
   // Works only for functional patterns
1. (&#x2308;&#x3C6;(X)&#x2309; &#x2227; &#x2308;&#x3B1;(Y)&#x2309;) &#x2192; (&#x3C6;(X) &#x2227; &#x2308;&#x3B1;(Y) &#x2227; &#x3C6;(X)&#x2309; &#x2192; &#x2022;&#x3B2;(Y))
   // Adding definedness conditions, works for function-like patterns
1. &#x2308;&#x3C6;(X)&#x2309; &#x2227; &#x2308;&#x3B1;(Y)&#x2309; &#x2227; &#x3C6;(X) &#x2227; &#x2308;&#x3B1;(Y) &#x2227; &#x3C6;(X)&#x2309; &#x2192; &#x2022;&#x3B2;(Y)
   // a &#x2192; (b &#x2192; c) = (a &#x2227; b) &#x2192; c
1. &#x3C6;(X) &#x2227; &#x2308;&#x3B1;(Y) &#x2227; &#x3C6;(X)&#x2309; &#x2192; &#x2022;&#x3B2;(Y)
   // If a &#x2192; b then a &#x2227; b = a
   // &#x2308;a &#x2227; b&#x2309; &#x2192; &#x2308;a&#x2309;
   // &#x2308;&#x3B1;(Y) &#x2227; &#x3C6;(X)&#x2309; -&gt; &#x2308;&#x3B1;(Y)&#x2309;
   // &#x2308;&#x3B1;(Y) &#x2227; &#x3C6;(X)&#x2309; -&gt; &#x2308;&#x3C6;(X)&#x2309;
</code></pre>
<h3 id="combining-rewrite-rules">Combining rewrite rules</h3>
<p>Let&#x2019;s say that our axioms are <code>&#x3B1;&#x2081;(X&#x2081;)&#x21D2;&#x3B2;&#x2081;(X&#x2081;)</code> &#x2026; <code>&#x3B1;&#x2099;(X&#x2099;)&#x21D2;&#x3B2;&#x2099;(X&#x2099;)</code>.</p>
<p>Let us attempt to combine <code>&#x3B1;&#x2081;(X&#x2081;)&#x21D2;&#x3B2;&#x2081;(X&#x2081;)</code> with <code>&#x3B1;&#x2082;(X&#x2082;)&#x21D2;&#x3B2;&#x2082;(X&#x2082;)</code>. Let us assume
that, when applying <code>&#x3B1;&#x2082;(X&#x2082;)&#x21D2;&#x3B2;&#x2082;(X&#x2082;)</code> to <code>&#x3B2;&#x2081;(X&#x2081;)</code> as described above, we get</p>
<pre class="language-text"><code>&#x3B2;&#x2081;(X&#x2081;) &#x2227; &#x2308;&#x3B2;&#x2081;(X&#x2081;)&#x2227;&#x3B1;&#x2082;(X&#x2082;)&#x2309; &#x2192; &#x2022;&#x3B2;&#x2082;(X&#x2082;)
</code></pre>
<p>We have an axiom <code>a -&gt; &#x2022;b</code> and we inferred <code>(P &#x2227; b) &#x2192; &#x2022;c</code>. Then, from the
axiom, we can infer <code>(P &#x2227; a) -&gt; &#x2022;(P &#x2227; b)</code>. By combining the two inferences we
get <code>(P &#x2227; a) &#x2192; &#x2022;&#x2022;(P &#x2227; c)</code>, which is equivalent to <code>(P &#x2227; a) &#x2192; &#x2022;&#x2022;c</code>.</p>
<p>The above holds because of this:</p>
<pre class="language-text"><code>Hypothesis: a &#x2192; &#x2022;b and b &#x2192; &#x2022;c
From b &#x2192; &#x2022;c, by framing: &#x2022;b &#x2192; &#x2022;&#x2022;c
From a &#x2192; &#x2022;b and &#x2022;b &#x2192; &#x2022;&#x2022;c: a &#x2192; &#x2022;&#x2022;c
</code></pre>
<p>Then we have</p>
<pre class="language-text"><code>(&#x2308;&#x3B2;&#x2081;(X&#x2081;)&#x2227;&#x3B1;&#x2082;(X&#x2082;)&#x2309; &#x2227; &#x3B1;&#x2081;(X&#x2081;))&#x2192;&#x2022;&#x2022;&#x3B2;&#x2082;(X&#x2082;)
</code></pre>
<p>By applying this iteratively, we get</p>
<pre class="language-text"><code>(&#x2308;&#x3B2;&#x2081;(X&#x2081;)&#x2227;&#x3B1;&#x2082;(X&#x2082;)&#x2309; &#x2227; &#x2308;&#x3B2;&#x2082;(X&#x2082;)&#x2227;&#x3B1;&#x2083;(X&#x2083;)&#x2309; &#x2227; ... &#x2308;&#x3B2;&#x2099;&#x208B;&#x2081;(X&#x2099;&#x208B;&#x2081;)&#x2227;&#x3B1;&#x2099;(X&#x2099;)&#x2309; &#x2227; &#x3B1;&#x2081;(X&#x2081;))&#x2192;&#x2022;&#x2022;&#x2026;&#x2022;&#x3B2;&#x2099;(X&#x2099;)
</code></pre>
<h3 id="removing-substitutions">Removing Substitutions</h3>
<p>Let us take an example. Let us say that we have two axioms:</p>
<pre class="language-text"><code>(X + Y) ~&gt; R =&gt; (X +Int Y) ~&gt; R    if isConcrete(X) and isConcrete(Y)
Z ~&gt; ([] * T) ~&gt; S =&gt; (Z * T) ~&gt; S   if isConcrete(Z)
</code></pre>
<p>If we try to combine them, we would get</p>
<pre class="language-text"><code>(X + Y) ~&gt; R =&gt; (Z * T) ~&gt; S
    if  isConcrete(X) and isConcrete(Y) and isConcrete(Z)
        and (Z == X +Int Y) and (R == ([] * T ~&gt; S))
</code></pre>
<p>Now, this is a bit ugly, but we can apply the substitutions for <code>Z</code> and <code>R</code>,
getting</p>
<pre class="language-text"><code>(X + Y) ~&gt; [] * T ~&gt; S =&gt; ((X +Int Y) * T) ~&gt; S
    if  isConcrete(X) and isConcrete(Y) and isConcrete(X +Int Y)
        and (Z == X +Int Y) and (R == ([] * T ~&gt; S))

// isConcrete(X +Int Y) is true
(X + Y) ~&gt; [] * T ~&gt; S =&gt; ((X +Int Y) * T) ~&gt; S
    if  isConcrete(X) and isConcrete(Y)
        and (Z == X +Int Y) and (R == ([] * T ~&gt; S))
</code></pre>
<p>This is better, but, since we&apos;re not actually using <code>Z</code> and <code>R</code>, we can
remove the substitution:</p>
<pre class="language-text"><code>(X + Y) ~&gt; [] * T ~&gt; S =&gt; ((X +Int Y) * T) ~&gt; S
    if  isConcrete(X) and isConcrete(Y)
</code></pre>
<p>To make it more formal, let us say that our axioms are
<code>&#x3B1;&#x2081;(X&#x2081;)&#x21D2;&#x3B2;&#x2081;(X&#x2081;)</code> &#x2026; <code>&#x3B1;&#x2099;(X&#x2099;)&#x21D2;&#x3B2;&#x2099;(X&#x2099;)</code> and
<code>P(X&#x2081;, &#x2026;, X&#x2099;)</code> is the merge predicate, and that the merged rule is
<code>&#x3B1;&#x2081;(X&#x2081;) &#x2227; P(X&#x2081;, &#x2026;, X&#x2099;) &#x21D2; &#x3B2;&#x2099;(X&#x2099;)</code>.</p>
<p>Let us further assume that there is some predicate <code>Q(X&#x2081;, &#x2026;, X&#x2099;)</code> and
a substitution <code>S(Y)</code> such that <code>P(X&#x2081;, &#x2026;, X&#x2099;) = Q(X&#x2081;, &#x2026;, X&#x2099;) &#x2227; S(Y)</code> and
the substituted variables do not occur on the right hand side of any
substitution.</p>
<p>Then we can apply the substitution to <code>&#x3B1;&#x2081;</code>, <code>&#x3B2;&#x2099;</code> and <code>Q</code>, getting <code>&#x3B1;&apos;</code>, <code>&#x3B2;&apos;</code> and
<code>Q&apos;</code> such that the variables in <code>Y</code> do not occur free in them.</p>
<p>Then the rule becomes</p>
<pre class="language-text"><code>&#x3B1;&#x2081;(X&#x2081;) &#x2227; Q(X&#x2081;, &#x2026;, X&#x2099;) &#x2227; S(Y) &#x21D2; &#x3B2;&#x2099;(X&#x2099;)
&#x3B1;&#x2081;(X&#x2081;) &#x2227; Q(X&#x2081;, &#x2026;, X&#x2099;) &#x2227; S(Y) &#x21D2; &#x3B2;&#x2099;(X&#x2099;) &#x2227; S(Y)  // a &#x2227; c &#x2192; b iff a &#x2227; c &#x2192; b &#x2227; c
&#x3B1;&apos; &#x2227; Q&apos; &#x2227; S(Y) &#x21D2; &#x3B2;&apos; &#x2227; S(Y)  // applying the substitution
&#x3B1;&apos; &#x2227; Q&apos; &#x2227; S(Y) &#x21D2; &#x3B2;&apos;  // a &#x2227; c &#x2192; b iff a &#x2227; c &#x2192; b &#x2227; c
&#x2200; Y . &#x3B1;&apos; &#x2227; Q&apos; &#x2227; S(Y) &#x21D2; &#x3B2;&apos;  // Explicit quantification
&#x3B1;&apos; &#x2227; Q&apos; &#x2227; (&#x2203; Y . S(Y)) &#x21D2; &#x3B2;&apos;  // &#x2200; x . (&#x3C6;(x) -&gt; &#x3B6;)  ==  (&#x2203; x . &#x3C6;(x)) -&gt; &#x3B6;
&#x3B1;&apos; &#x2227; Q&apos; &#x21D2; &#x3B2;&apos;  // (&#x2203; x . x=&#x3C6;) is always top
</code></pre>
<h3 id="distributing-over-predicate-disjunction">Distributing over predicate disjunction</h3>
<p>This is useful when we&apos;re doing AC unification, say, because two merged rules
use a map, perhaps the <code>state</code> map.</p>
<p>If the merge rule is <code>&#x3B1;&#x2081;(X&#x2081;) &#x2227; (P(X&#x2081;, &#x2026;, X&#x2099;) &#x2228; Q(X&#x2081;, &#x2026;, X&#x2099;)) &#x21D2; &#x3B2;&#x2099;(X&#x2099;)</code> then we
may have substitutions inside <code>P</code> and <code>Q</code>, but we may not be able to apply them
directly to get a simplified rule. But we can do this:</p>
<p>``
&#x3B1;&#x2081;(X&#x2081;) &#x2227; (P(X&#x2081;, &#x2026;, X&#x2099;) &#x2228; Q(X&#x2081;, &#x2026;, X&#x2099;)) &#x21D2; &#x3B2;&#x2099;(X&#x2099;)
(&#x3B1;&#x2081;(X&#x2081;) &#x2227; P(X&#x2081;, &#x2026;, X&#x2099;)) &#x2228; (&#x3B1;&#x2081;(X&#x2081;) &#x2227; Q(X&#x2081;, &#x2026;, X&#x2099;)) &#x21D2; &#x3B2;&#x2099;(X&#x2099;)
(&#x3B1;&#x2081;(X&#x2081;) &#x2227; P(X&#x2081;, &#x2026;, X&#x2099;) &#x21D2; &#x3B2;&#x2099;(X&#x2099;)) &#x2227; (&#x3B1;&#x2081;(X&#x2081;) &#x2227; Q(X&#x2081;, &#x2026;, X&#x2099;) &#x21D2; &#x3B2;&#x2099;(X&#x2099;))
// (a &#x2228; b) -&gt; c iff (a -&gt; c) &#x2227; (b -&gt; c)</p>
<pre class="language-text"><code>
so we can get two rules with an `and` between them, which means that we
actually get two separate rules.

Applying rules to some initial configuration
--------------------------------------------

The result is the same as above, except that, if the initial configuration is
`&#x3C6;(X)`, we get

</code></pre>
<p>( &#x2308;&#x3C6;(X)&#x2227;&#x3B1;&#x2082;(X&#x2081;)&#x2309;
&#x2227; &#x2308;&#x3B2;&#x2081;(X&#x2081;)&#x2227;&#x3B1;&#x2082;(X&#x2082;)&#x2309;
&#x2227; &#x2308;&#x3B2;&#x2082;(X&#x2082;)&#x2227;&#x3B1;&#x2083;(X&#x2083;)&#x2309;
&#x2227; ...
&#x2227; &#x2308;&#x3B2;&#x2099;&#x208B;&#x2081;(X&#x2099;&#x208B;&#x2081;)&#x2227;&#x3B1;&#x2099;(X&#x2099;)&#x2309;
&#x2227; &#x3C6;(X)
)
&#x2192;  &#x2022;&#x2022;&#x2026;&#x2022;&#x3B2;&#x2099;(X&#x2099;)</p>
<pre class="language-text"><code>
Now, if `&#x3C6;(X)=X`, then this formula becomes equivalent to the one above.
</code></pre>
</body></html></div>
        </main>

        <!-- Page ToC -->
        <div class="col-12 col-md-3 col-xl-2 py-md-3 bd-sidebar page-toc mb-3">
          
<div>
<details style="padding:0.25rem 0;;padding-left: 0px;" open>
            <summary class="bd-toc-link-wrapper">
              <a href="#combining-rewrite-axioms" class="bd-toc-link">Combining rewrite Axioms</a>
              </summary>
            <div>
              <div class="bd-toc-link-wrapper" style="padding:0.25rem 0;">
              <a
                href="#summary"
                class="bd-toc-link"
                style="padding-left: 8px;;"
              >
                Summary
              </a></div><div class="bd-toc-link-wrapper" style="padding:0.25rem 0;">
              <a
                href="#the-general-transformation"
                class="bd-toc-link"
                style="padding-left: 8px;;"
              >
                The general transformation
              </a></div><details style="padding:0.25rem 0;;padding-left: 8px;" open>
            <summary class="bd-toc-link-wrapper">
              <a href="#implementation-concerns" class="bd-toc-link">Implementation concerns</a>
              </summary>
            <div>
              <div class="bd-toc-link-wrapper" style="padding:0.25rem 0;">
              <a
                href="#eliminating-variables"
                class="bd-toc-link"
                style="padding-left: 16px;;"
              >
                Eliminating variables
              </a></div><div class="bd-toc-link-wrapper" style="padding:0.25rem 0;">
              <a
                href="#using-function-like-patterns"
                class="bd-toc-link"
                style="padding-left: 16px;;"
              >
                Using function-like patterns
              </a></div><div class="bd-toc-link-wrapper" style="padding:0.25rem 0;">
              <a
                href="#combining-rewrite-rules"
                class="bd-toc-link"
                style="padding-left: 16px;;"
              >
                Combining rewrite rules
              </a></div><div class="bd-toc-link-wrapper" style="padding:0.25rem 0;">
              <a
                href="#removing-substitutions"
                class="bd-toc-link"
                style="padding-left: 16px;;"
              >
                Removing Substitutions
              </a></div><div class="bd-toc-link-wrapper" style="padding:0.25rem 0;">
              <a
                href="#distributing-over-predicate-disjunction"
                class="bd-toc-link"
                style="padding-left: 16px;;"
              >
                Distributing over predicate disjunction
              </a></div>
            </div>
          </details>
        
            </div>
          </details>
        
</div>

        </div>
        <div class="btn btn-rv-blue page-toc-toggle-btn"></div>
        <!-- End Page ToC -->
      </div>
    </div>
<!-- The footer is now controlled by the k-web-theme git submodule -->
<footer id="rvsite-footer" class="app-footer text-md-left text-center">
  <div class="container">
    <div class="row align-items-center">
      <div class="col-md-4 mb-md-0 mb-4">
        <a href="https://runtimeverification.com/" target="_blank">
          <picture>
            <source
              srcset="
                https://runtimeverification.com/assets/img/rv-logo-dark.png
              "
              media="(prefers-color-scheme: dark)"
            />
            <img
              class="logo-dark"
              src="https://runtimeverification.com/assets/img/rv-logo.png"
              alt="Runtime Verification logo"
              style="height: 32px"
            /> </picture
        ></a>
        <p class="mt-2 text-md-left copyright">
          <a href="https://goo.gl/maps/NYzr2iKpXMgEmQ2F6" target="_blank"
            >102 E Main St #500, Urbana, IL 61801</a
          >
        </p>
      </div>
      <div class="col-md-4 text-md-center mb-md-0 mb-4"></div>
      <div class="col-md-4 mb-md-0 mb-4 text-md-right">
        <p class="copyright">2021 © all rights reserved</p>
      </div>
    </div>
  </div>
</footer>

    <script src="../../assets/js/index.js"></script>
  </body>
</html>
